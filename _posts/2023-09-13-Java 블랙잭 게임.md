---
title: 블랙잭 게임 - Java
date: 2023-09-13
categories: [etc]
tags: [blackjack] 
---

## OOP
대학 4년을 다니면서 객체지향 설계에 대한 많은 얘기를 들었다.

자바는 객체지향이지만 실제로 이 장점을 제대로 활용하고 프로젝트를 설계하거나 구성하는 일은 드문 것 같다.

정규과정에서는 아직도 데이터 중심 설계 방식의 중요도를 많이 얘기하고 있다.

프로그램을 설계하는데 있어서 가장 중요한 것은 DB 설계를 작성하는 것이라고 한다.

실제로 다양한 프로젝트 과목에서는 클린 코드나 설계를 중점적으로 보는 것이 아니라 프로젝트의 결과물과 계획서 등의 페이퍼워크를 중시하고 있다.

사실 이것도 매우 중요한 일이다. 하지만, 실제 현업에서 지양하고 있는 Java 컨벤션과 클린코드는 어떤 것일지 궁금해졌다. 

최근  [객체지향의 사실과 오해](https://www.yes24.com/Product/Goods/18249021)를 읽고 많은 생각이 달라졌다. 

객체간의 관계를 중심으로 생각해야 하고, 그것을 우선적으로 바라봐야 한다는 것을 추상적으로나마 알게되었다.

그리고 현업에서 종사하시는 선배의 TDD 경험을 토대로 Test의 중요성을 알게 되었고, JUnit을 사용해볼 것이다.

그래서 , JUnit을 학습하고 진짜 OOP에 대해 공부해보고자 한다.


___

## 프로젝트 목표
최대한 현업에 필요한 컨벤션을 준수할 것이고, 객체지향을 추구하고자 할 것이다.

그러기 위해서는 객체지향이 무엇인지 알아야 하고, 이를 준수하기 위해 지켜야할 규칙을 알아야 한다.

대표적으로 객체지향 생활 체조 원칙이 있다.


 >  객체지향 생활 체조 원칙은 소트웍스 앤솔러지(ThoughtWorks Anthology) 라는 책에 나오는 원칙이다.<br/>
	소트웍스 앤솔로지에서는 9가지 원칙을 준수하면서 객체지향을 추구할 수 있다고 한다.<br/><br/>
	1. 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다.<br/>
	2. else 예약어를 쓰지 않는다.<br/>
	3. 모든 원시 값과 문자열을 포장한다.<br/>
	4. 일급 컬렉션을 쓴다.<br/>
	5. 한 줄에 점을 하나만 찍는다.<br/>
	6. 줄여 쓰지 않는다(축약 금지).<br/>
	7. 모든 엔티티를 작게 유지한다.<br/>
	8. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.<br/>
	9. getter/setter/프로퍼티를 쓰지 않는다.<br/>


객체지향의 사실과 오해를 기반으로 하나의 객체는 하나의 책임만을 담당해야 한다.

이를 위해 하나의 메소드는 한 가지 책임만을 수행할 것이다.

그러기 위해서는 메소드의 라인이 적어져야 할 것이다.

42서울에서 경험했듯이, 메소드의 라인수가 15라인으로 정의하면 메소드의 역할이 분명해지고,
코드 리뷰를 하는 입장에서도 편리했던 기억이 난다.

이를 토대로 메소드의 라인수가 15라인을 넘어가지 않게 할 것이다.


___

### 테스트 코드

코드를 작성하다 보면 내가 작성한 코드가 맞는 코드인지 검증이 필요할 때가 많다.

기존에는 일일히  sout 으로 찍어보거나 log를 찍어보면서 테스트 했었지만 매우 번거롭고 이 과정에서 놓치는 부분이 많이 발생하게 된다.

이러한 과정을 거치면서 결국엔 하나마나한 유사 단위 테스트를 진행하면서 결국 통합 테스트를 진행하는 과정에서 이전에 놓쳤던 부분의 문제가 터지면서 되돌릴 수 없거나, 수정 불가능한 수준까지 도달하게 된다.

그래서 작은 단위의 유닛 테스트를 진행하고 내가 만든 코드의 유효성을 검증하는 테스트 코드를 작성할 것이다.

테스트코드의 FIRST 규칙을 준수하며 작성할 것이다.

> FIRST 규칙 <br/>
Fast: 테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한다.<br/>
Independent: 각각의 테스트는 독립적이며 서로 의존해서는 안된다.<br/>
Repeatable: 어느 환경에서도 반복 가능해야 한다.<br/>
Self-Validating: 테스트는 성공 또는 실패로 bool 값으로 결과를 내어 자체적으로 검증되어야 한다.<br/>
Timely: 테스트는 적시에 즉, 테스트하려는 실제 코드를 구현하기 직전에 구현해야 한다.<br/>

___
## 게임 OverView
블랙잭을 구현할 것이다.

Player와 딜러 두 명의 유저만 게임을 진행한다.

덱은 6팩(52 * 6)으로 진행된다.

블랙잭의 기본적인 Hit와 Stand 그리고 Double Down만 사용할 것이다, 에이스는 무조건 1로 지정할 것이다.

게임은 Player가 게임 시작을 요청하면 게임이 시작되고, 딜러에게 카드 두 장, Player에게 카드 두 장을 준다.


이 때, Player의 카드가 21이라면 블랙잭이므로 사용자의 턴을 마친다.

21이 아니라면, 사용자의 턴을 진행한다. 


Player가 매 턴 마다 Hit, Stand, Double Down을 요청할 수 있다.


Player가 Hit를 입력하면 카드를 한장 Draw 하고 턴을 이어간다.

Player가 Double Down을 입력하면 카드를 한 장 Draw하고 턴을 종료한다.

Double Down은 카드를 두 장 소지하고 있을 때만 가능하다.

Double Down시, 베팅금액을 두 배로 올린다.

Player가 Stand를 입력할 시 사용자의 턴이 종료된다.

Player가 21을 초과하면 Bust로 딜러의 카드를 뽑지않고 게임을 종료한다.


딜러는 Player의 턴이 끝나면 두 번째 카드를 공개한다.

딜러는 카드의 총 합이 16이하이면 덱에서 카드를 한 장씩 뽑는다.

딜러의 카드가 17이상이 되거나 21을 초과하면 게임을 종료한다.

21을 초과할 경우 Bust이다.

Bust일 경우 Player의 배팅금액의 두 배를 Player에게 지불한다.


만약 Player보다 딜러의 카드 총 합이 높을 경우, 사용자의 베팅 금액을 딜러가 가져간다.

만약 Player와 딜러의 카드 총 합이 같을 경우 사용자는 베팅 금액을 회수해 간다.

만약 Player가 딜러보다 카드 총 합이 높을 경우, 사용자는 베팅 금액의 두 배를 가져간다.


___

### 기능 요구사항

1. 덱
: 덱은 총 6팩으로 진행된다. *52 \* 6 개의 카드* 로 구성되어 있다.
: 카드는 *1 ~ 9 까지 존재하고 K, Q, J 는 10으로 치환*한다.
: 덱은 처음에 랜덤으로 **섞어 준다.**
: 덱의 사이즈가 **53 * 3 개 미만이 되면 새로운 6팩의 덱을 준비하고 위의 과정을 다시 진행**.
: 요청이 들어오면 **덱에 있는 상단의 카드를 한 장 반환**한다.
: **덱의 남은 개수를 반환**한다.

2. 게임 매니저
: Start, 유저의 요청을 받아 게임을 시작한다.
: Finish, 필드의 카드를 모두 제거한다.
: State, 게임 진행 상태를 리턴한다.
: Hit, 요청자의 카드를 한 장 드로우 한다.
: Stand, 요청자의 턴을 마친다.
: DoubleDown, 요청자의 배팅 금액의 두 배를 받고, 카드를 한장 draw하고 턴을 마친다. 
: isDead, 요청자의 Hit, DoubleDown 진행에 따라 21을 초과했는지 체크한다. 초과시 게임을 마친다.

3. Player
: Init, Player와 Dealer의 정보를 복사.
: Show, 현재 금액, 보유 카드를 확인할 수 있다.
: ShowField, 필드에 깔려있는 덱의 정보, 딜러의 카드, 나의 카드를 모두 확인할 수 있다.
: Bat, 배팅 금액을 설정한다.
: Start, 게임 시작을 요청한다.
: Act, Hit, DoubleDown, Stand를 결정한다.
: Exit, 게임을 종료한다.
: WInner, 승자 판별

4. Dealer
: Init, 유저의 턴이 종료되면 Draw를 시작한다.
: Draw, 덱에서 상단의 카드를 한 장 뽑는다.
: isBust, 매 Draw마다  21을 초과했는지 확인한다.
: Finish, 카드의 총 합이 17이상이면 Stand 한다.
: 비교,  딜러의 카드 총 합과 Player의 카드 총 합을 비교하여 결과를 리턴한다.

5. Views
: 사용자로부터 입력값을 받는다.
	- Game Start, Hit, Stand, Double Down
: 사용자에게 필드를 출력해준다.
	- 딜러 카드, 보유 카드
: 사용자의 현재 상태를 출력한다.
	- 보유 카드, 소지 금액
