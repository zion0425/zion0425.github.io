---
title: stream으로 컬렉션 다루기
date: 2023-09-14
categories: [Java]
tags: [collection]
---

컬렉션의 내부에 있는 `Object`를 꺼내기 위해선 `for`나, `foreach`를 사용할 수 있습니다. 현재 진행하고 있는 Blackjack에서는 `ArrayList`안에 Card라는 객체를 담고 있으며 Card를 꺼내쓰기 위해선 루프를 통해 순회 과정을 거쳐야 합니다.

현재 Deck을 구성하고 있는 각각의 카드는 총 4개의 suit(Diamond, Club, Spade, Heart)로 구분되어 있고 각 suit마다 1 ~ K 까지 13개의 넘버가 들어 있습니다. 블랙잭은 보통 6팩을 쓰기 때문에 덱 안에 들어있는 카드의 총 개수는, 4개의 suit * 13개의 넘버 * 6팩 개로 312로 구성되어 있습니다.

이렇게 구성된 덱에 특정 suit에 1~k 까지 모든 숫자가 6번씩 들어가 있는지 확인하기 위해 이중 for문을 이용하여 구현한 현재 코드입니다.

예를 들어, club 문양의 카드가 1 ~ k 까지 존재하는지 살펴보고 총 6팩을 사용하기 때문에 club 문양의 카드가 13 * 6 개가 있는지 확인하는 것입니다.

덱의 모든 카드에 해당하는 숫자들이 존재하는지 일일히 비교하는 코드입니다.

```java
// DeckTest.java
@Test
@DisplayName("club 문양이 13개 * 6팩 가 있으면 성공!");
void currectClubInDeck(){
	ArrayList<Card> d = new Deck().getDeck();
	String[] nums = {"1", "2", ... , "10", "J", "Q", "K"};
	
		for(Card c : d){
			for(String num : nums){
				if( c가 club이면서 num일 경우 )
					clubCount++;
					...
			}
		}
}
```

만약 arr안에 수백개의 카드가 들어 있고, 모든 c에 대해서 club문양의 숫자에 해당하는 카드를 찾는다고 가정하면, 순회는 총 수백번 이루어 지고 매 번 해당하는 카드를 찾기 위해 `indexOf`, `contains`와 같은 자바 API, 혹은 `Iterator`를 사용하여야 합니다.

이러한 순회 과정을 여러번 거쳐야 한다면 성능 저하는 물론이고 코드가 복잡해지고 알아보기 힘들어 집니다.

java 8 부터 지원하는 `stream`을 통해 이 문제를 해결할 수 있었습니다. 

`Iterator`와 `stream`의 가장 큰 차이점은 외부 반복자와 내부 반복자에 있었습니다.

Iterator는 외부 반복자를 통해 Collection을 순회하게 되고, stream은 내부 반복자를 통해 컬렉션을 순회합니다..

외부 반복자는 사용자가 직접 코드로 `for` 와 같은 loop를 직접적으로 선언하여 컬렉션을 순회하는 방식입니다.

`stream`은 컬렉션에 있는 요소들을 하나씩 람다식을 통해 처리할 수 있도록 도와주는 내부 반복을 사용합니다.

또한, 실행 순서가 상관없는 로직에서는 parellsStream을 사용해서, 사용자가 별도의 멀티쓰레드를 구현하지 않아도 내부 반복자가 **병렬처리**를 도와줄 수 있습니다.

기존의 코드를 `stream`을 이용해서 아래와 같은 코드로 변경하였습니다.

```java
	long clubCount = 0;
        for(String num : nums) {
            clubCount += d.getDeck().stream()
                    .filter(card -> card.showCardInfo().equals("diamond"+number))
                    .count();
        }
```

`stream`은 파이프라이닝이라는 특징을 가지고 있습니다.

`stream`연산들은 서로를 연결하여 파이프라인을 구성할 수 있도록 자신을 반환합니다. 그 반환된 값은 다음 연산에 입력값으로 들어가게 됩니다. 마치 Shell의 \|과 같은 기능을 합니다.

위의 코드에서는 `filter`는 말 그대로`stream`요소에 대한 필터링을 하는 중간 연산이고, filter를 통해 찾은 값들의 개수를 구하는 count의 최종연산을 통해 값을 반환합니다. 최종적으로 각 num당 6개의 카운트가 반환되게 되고 13번의 루프를 돌면 총 13 *6 을 반환하게 됩니다.

이처럼 `stream`을 사용하면 기존의 코드에 비해 훨씬 가독성이 향상되는 것을 볼 수 있습니다.

### 컬렉션을 다룰 땐 무조건 `stream`이 정답인가?

결론부터 말하자면, 대부분의 상황에선 `stream`을 사용하는 것이 유리합니다.

하지만,  `stream`에서 제공하는 것과 `Iterator`에서 제공하는 것을 하나씩 살펴보다보면 어느 상황에서 어떤것을 사용해야 유리한지 알 수 있습니다.

`Iterator`는 컬렉션의 데이터를 직접적으로  변경하거나 삭제할 수 있습니다. 하지만 `Stream`은 일반적으로 데이터를 변형 하거나 필터링할 때 새로운 스트림을 생성하므로 원본 데이터를 직접적으로 변경할 수 없습니다.

큰 데이터 집합을 다룰 때, 모든 데이터에 접근하는 것이 아니라, `Iterator`로 필요한 데이터만 로드하고 처리하는데 성능 및 메모리 측면에서 유리할 수 있습니다.

이처럼 일반적으로 `Stream`이 주는 이점이 크지만 간혹 `Iterator`가 더 도움이 될 수 있습니다.
