---
title: myBatis
date: 2024-04-19
categories: [myBatis]
tags: [myBatis]
published: false
---

## myBatis

Object와 SQL사이의 Mapping을 처리하는 ORM(Object Relational Mapping) 프레임워크이다.

myBatis는 SQL을 별도의 파일로 분리해서 관리한다.

SQL과 Object 사이의 parameter mapping을 자동으로 해준다.

기존의 JDBC를 직접 사용하기 위해 DB와 연결하고, Connection을 생성하고 PreparedStatement를 생성하고, ResultSet을 처리하는 등의 번거로운 작업을 처리하지 않아도 된다.

이처럼 고정된 패턴의 코드를 myBatis가 대신 처리해준다.

myBatis를 통해 개발자는 SQL에만 집중할 수 있게 된다.

개발자는 Dto와 Sql만 작성하면 된다.

먼저, myBatis-config에 DB정보를 설정한다.

설정파일에 mybatis-dtd에 맞게 설정한다.

기존의 xml 설정 파일에 properties들이 순서 무관하게 나열되어 있어도 톰캣이 실행 순서를 보장해주지만, mybatis-config.xml은 dtd에 맞게 설정해야 한다.

```xml
<!ELEMENT configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)>
```

위에서 정의된 element들을 순서대로 나열해야 한다.

```xml
<!-- myBatis-config.xml -->
<configuration>

    <!-- properties에 사용될 변수들을 정의한다 -->
    <properties resource="db.properties"/>

    <!-- Alias 지정 -->
    <typeAliases>
        <typeAlias alias="User" type="com.ssafy.dto.User"/>
    </typeAliases>

    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
    </environments>

    <mappers>
        <mapper resource="mapper/UserMapper.xml"/>
    </mappers>
</configuration>

<!-- mapper/UserMapper.xml -->
<mapper namespace="mapper.UserMapper">
    <!-- SQL Query 작성 -->
</mapper>
```

이렇게 설정된 myBatis-config.xml을 읽어들이기 위해 SqlSessionFactory를 생성한다.

```java

public class SQLSessionFactoryManager {
    private SqlSessionFactory sqlSessionFactory;

    static {
        try{
            String resource = "com/ssafy/myBatis-config.xml";
            Reader reader = Resources.getResourceAsReader(resource);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}

```

SqlSessionFactory를 통해 SqlSession을 생성하고, SqlSession을 통해 SQL문을 실행한다.

앞서 config에서 mapper를 설정했기 때문에 mapper/UserMapper.xml에 SQL문을 작성한다.

동일한 id가 존재할 경우가 생길 수 있기 때문에 이를 구분하기 위해 namespace를 사용한다.

namespace의 네이밍 컨벤션은 mapper.패키지명.클래스명이다.

```xml
<!-- mapper/UserMapper.xml -->
<mapper namespace="mapper.UserMapper">
    <select id="selectUser" parameterType="int" resultType="User">
        SELECT * FROM users WHERE id = #{id}
    </select>

    <!-- User(DTO)를 사용할 경우 -->
    <select id="selectUser" parameterType="User" resultType="User">
        SELECT * FROM users WHERE id = #{id}
    </select>
</mapper>
```

```java
public class Main {
    public static void main(String[] args) {
        try(SqlSession sqlSession = SQLSessionFactoryManager.getSqlSession()) {
            User user = sqlSession.selectOne("mapper.UserMapper.selectUser", 1);
            sqlSession.commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

이떄, userDto를 반환값인 userDto property명과 column명이 일치해야 한다.

만약 컬럼명이 Dto의 property명과 다르다면, alias를 사용하여 매핑해준다.

DTO의 이름과 form의 name과 DB의 column명을 일관되게 작성하는 것이 DI에 유리해 보인다.

하지만, 보안상 컬럼명이 노출되는 것을 방지하기 위해 일반적으로 alias를 사용하는 것이 좋다.

mapper의 resultMap을 사용하면, 컬럼명과 DTO의 property명을 일치시키지 않아도 된다.

```xml
<mapper namespace="mapper.UserMapper">
    <resultMap id="userMap" type="User">
        <result property="id" column="user_id"/>
        <result property="name" column="user_name"/>
        <result property="email" column="user_email"/>
    </resultMap>

    <select id="selectUser" parameterType="int" resultMap="userMap">
        SELECT * FROM users WHERE id = #{id}
    </select>
</mapper>
```
