---
title: 재귀함수 #1
---

## 목차

<a href = ""> 1. </a>
<a href = ""> 1. </a>
<a href = ""> 1. </a>

## 개요

문제 해결 능력을 기르기 위해 자료구조를 이해하고 알고리즘 기법을 습득한다.

알고리즘은 문제 해결을 위한 절차를 의미한다.

문제를 풀기 전, 문제 유형(제약 조건)과 시간복잡도를 파악하여 의사코드를 작성한다.

### 알고리즘 고려 요소

- 정확성
- 작업량 (시간복잡도)
- 메모리 사용량 (공간복잡도)
- 단순성
- 최적성

### 시간 복잡도

- 최선(Best Case)

  - 빅 오메가 표기법 사용
  - 최선의 시나리오로 최소한 걸리는 시간

- 최악(Worst Case)

  - 빅오 표기법 사용
  - 최악의 시나리오로 최대로 오래 걸리는 시간

- 평균(AverageCase)

  - 빅세타 표기법
  - 평균 시간

### 공간 복잡도

생성하는 객체, 배열 크기

### 복잡도 접근적 표기

연산수에 대한 다항식 (n -> ∞)

"가장 큰 영향력을 주는 n에 대한 항"만 표시

계수는 생략

## 반복과 재귀

재귀란, 작은 개념과 부분 문제를 동일한 함수로 처리하여 더 이상 부분문제로 나눌수 없을 때까지 반복하는것

반복문은 순차적으로 상태가 변하지만, 재귀는 상태를 보존할 수 있다.

스택에 함수 스택이 쌓이기 때문에, 반복문을 권장하기도 한다.

### 재귀 함수(Recursive function)

1. 함수 정의(역할)
1. 함수 수행에 필요한 결정적요인(매개 변수), 값 설계
1. 재귀 종료조건

`Factorial.java`

```java
int factorial(int n) {
    if (n <= 1) return 1;
    else return n * factorial(n - 1);
}
```

f(n) = n! 계산값 반환

기저조건. n == 1

n \* (n -1);

`n개 중 k개 뽑는 경우의 수`

f(n, k) = n개 중 k개를 뽑는 경우의 수 계산

기저조건.

k = 1 => n<br/>
n == k => 1

= n-1Ck-1 + n-1Ck

`피보나치 수열`

F0 = 0, F1 = 1, F2 = F1 + F0
Fi = Fi-1 + Fi-2 for i >= 2

```java
fibo(n) :
    if n < 2 : return n
    else     : return fibo(n - 1) + fibo(n - 2)
```
