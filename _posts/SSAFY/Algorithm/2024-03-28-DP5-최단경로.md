---
title: LIS
date: 2024-03-28
categories: [Algorithm]
tags: [LIS]
published: false
---

## 목차

<a href = "#1"> 1. 플로이드 워샬 </a>

## 개요

모든 쌍 최단 경로, 모든 정점 $n_i ~ n_j$ 까지의 모든 최단경로를 구하는 문제

다익스트라는 시작 정점이 고정되어 있고, 가중치가 양수일때 최단경로를 구할 수 있다.

모든 쌍 최단 경로를 구하기 위해서 다익스트라를 사용하면 시작정점 i에서 $(n_i)^2$로 최단경로를 구하고, 이를 다른 모든 시작 정점의 수만큼 n번 반복하면 값을 구할 수 있다.

다익스트라의 인접리스트로 구현하면 희소그래프에 근접할수록, 시간복잡도가 $O(n^3)$ 보다 조금 더 빠르다.

| 최단 경로  | 다익스트라          | 플로이드 워샬 | BFS  |
| ---------- | ------------------- | ------------- | ---- |
| 가중치     | 양의 정수           | 무관          | 없음 |
| 시간복잡도 | $O(n^3)$ - 인접행렬 | $O(n^3)$      |      |

> Brute-force는 순열을 구해야 하므로, (n - 2)! 의 모든 경로를 계산해야 한다.

## <font id = "1">플로이드 워샬</font>

워샬은 모든 쌍의 경로 존재 여부를 찾아내는 DP를 찾아냈고, 플로이드는 이를 변형하여 모든 쌍 최단 경로를 찾는 알고리즘을 고안했다.

동적 테이블 $Adj_ij$ 는 $i ~ j$ 까지의 최적해를 저장하는데, k만을 경유한 최단경로를 저장한다.

```java
define max = {최대입력 * 정점 수};
D[i][j]
function init () {
    int start, end, value = br.readLine();
    DP[i][j] = i == j ? 0 ; max;
    DP[start][end] = value;
}

function (D[][]) {
    for k = 1 ~ n // 경유 노드 k
        for i = 1 ~ n // 시작 정점 i
            if i == k continue; // 출발지와 경유지가 같음
            for j = 1 ~ n // 도착 정점 j
                if j == k || j == i // 도착지와 경유지, 출발지가 같음
                // D[i][j] -> 직접 연결
                // D[i][k] -> 시작에서 경유지로 가는 최소 비용
                // D[k][j] -> 경유지에서 도착지로 가는 최소비용
                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);
}
```

양의 가중치는 조건문 필요 없음
