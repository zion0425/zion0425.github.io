---
title: DP
date: 2024-02-27
categories: [Algorithm]
tags: [DP]
published: false
---

## 목차

1. <a href = "#memoization"> Memoization </a>
1. <a href = "#dp"> DP </a>

## <font id = "memoization"> 메모이제이션 </font>

메모이제이션은, 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 전체적인 실행속도를 빠르게 하는 기술

`fibonacci.java`

```java
fibo(n)
    if n < 2 return n
    return fibo(n) = fibo(n -1) fibo(n - 2);
```

중복된 계산이 발생, 개선하기 위해 각 항의 값을 저장하는 1차원 배열 생성

`fibonacci.java`

```java
fibo(n)
    if n >= 2 && memo[n] == 0
        memo[n] = fibo(n - 1) + fibo(n - 2)
    return memo[n];
```

메모이제이션은 추가적인 메모리 공간이 필요하다.

재귀호출은 여전히 수행하면서 함수 호출 스택을 사용한다.

이를 해결하기 위해 재귀를 사용하지 않는다.

## <font id = "dp"> DP </font>

동적 계획법은 문제를 작은 문제로 나누어 그리디처럼 최적화 문제를 해결하는 알고리즘이다.

**중복 부분문제** 구조와, **최적 부분문제** 구조의 요건을 가지고 있어야 한다.

### 중복 부분 문제

DP는 큰 문제를 이루는 작은 문제들을 해결하고, 작은 문제들의 최적해를 이용하여 순환적으로 큰 문제를 해결한다.

부분 문제들이 중복되어 발생한다.

순환적인 관계를 표현하기 위해 일반적으로 **점화식**을 사용한다.

먼저 계산된 작은 문제의 해를 메모리상(동적 테이블)에 저장한다.

### 최적 부분 문제

최적화의 원칙, 어떤 문제의 해가 최적이면 그 해를 구하는 작은 문제들의 해도 최적이어야 한다.

> 경우의수를 구하는 문제에도 동적계획법이 가능하다.

## 분할 정복과 DP

**분할정복**은 연관 없는 부분 문제로 분할한다.

이를 재귀적으로 하향식 접근을 통해 해를 구해 결합한다.

**DP**는 연관있는 부분 문제로 분할한다.

점화식을 통해 상향식 접근으로, 모든 부분 문제를 한 번만 계산하고 결과를 저장하여 재사용한다.

## DP 적용 접근 방법

1. 최적해 구조의 특성을 파악한다.
   - 문제를 부분문제로 나눈다.
2. 최적해의 값을 재귀적으로 정의한다.
3. 상향식 방법으로 최적해의 값을 계산한다.
   - 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장
   - 테이블에 저장된 부분 문제의 해를 이용해 큰 부분문제를 해결한다.
