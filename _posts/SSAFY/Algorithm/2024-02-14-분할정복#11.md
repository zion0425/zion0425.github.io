---
title: 분할정복
date: 2024-02-14
categories: [Algorithm]
tags: [분할정복]
published : false
---

## 분할정복

분할 -> 정복 -> 통합

큰 문제를 작은 문제로 **분할**하여 작은 부분 문제를 **정복**한 뒤, **통합**하여 최종 해를 도출

`$c^n$을 구하는 반복문`

```java

for i ~ n
    res += n * n

// O(N)
```

`$c^n$ 분할 정복`

$C^4
= C \* ... \* C
= (C^2)^2

C^n
= C^(n-1)/2$

$O(log_2n)$

```java

rec(x, n)
    if n % 2 == 0
        res = rec(x, n / 2)
        return res * res;
    else
        res = rec(x, (n - 1 / 2))
        return res * res * x;
```

## 백트래킹

여러 선택지를 완전탐색을 통해 중간에 올바른 선택지로 판별하는 방식이다.

상태공간트리로 구성할 수 있다. 이전 선택지의 상태를 기록해야 한다.

N-Queen 의 경우, 모든 경우를 확인하는 것이 아닌 가능한 선택지를 중간에 판별해야 한다.

`BFS`의 경우, 모든 상태를 저장하여 각각의 시나리오별로 이전 상태를 가지고 있어야 하므로 구현이 어렵다.

이를 `DFS`로 구현하면, 하나의 시나리오를 기록하여 탐색하므로 구현이 용이하다.

8-Queens의 경우, 약 44억개의 후보 해 중에 92개의 실제 해를 찾아야 한다.

다음 자리를 선택할 때, 이전 상태를 고려하여 불가능한 후보해의 선택지에 도달하면, 부모 노드로 돌아가 다른 노트를 탐색한다.

퀸 문제의 경우 제한사항을 아래와 같이 설정할 수 있다.

1. 부모와 같은 행에 퀸을 두지 않는다.

1. 부모와 같은 열에 퀸을 두지 않는다.

1. 부모의 대각선에 퀸을 두지 않는다.

이렇게 제한사항을 두어 **가지치기(pruning)**를 진행한다.

실제 구현을 위해선 재귀를 사용하고 메소드 호출 전 체크, 메소드 호출 후 체크 하는 방식으로 나뉜다.

```java
backTrack(node v)
		if promising (v) == false
			return ;
		if v == leafNode
			sout (solution);
		else
			for choicePosition : v
				backTrack(choicePosition);
```
